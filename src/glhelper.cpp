
#include "glhelper.hpp"

GLFWwindow* windowHandle = NULL;

GLFWwindow* GLHelper::window() {
    return windowHandle;
}

bool GLHelper::init(int width, int height, const char* name) {

	if( glfwInit() != true ) {
		logger::fatal( "Failed to initialize GLFW!" );
		return false;
	}

	glfwSetErrorCallback( [] (int err, const char* msg) -> void {
		logger::warn( "GLFW Error: " + std::string(msg) );
	} ); 

	// glfwWindowHint(GLFW_SAMPLES, 2);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

	windowHandle = glfwCreateWindow( width, height, name, NULL, NULL);

	glfwSetInputMode(windowHandle, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
	glfwSetInputMode(windowHandle, GLFW_STICKY_KEYS, GL_TRUE);

	if( windowHandle == NULL ) {
		logger::fatal( "Failed to open GLFW window!" );
		return false;
	}

	glfwSetWindowSizeCallback( windowHandle, [](GLFWwindow* window, int width, int height) -> void {
		glViewport(0, 0, width, height);
		PathTracer::instance()->resize(width, height);
	} );

	// TODO move somewhere else
	glfwSetKeyCallback( windowHandle, [] (GLFWwindow* window, int key, int scancode, int action, int mods) -> void {
		if( key == GLFW_KEY_SPACE && action == GLFW_PRESS ) GLHelper::screenshot("screenshot.png");
	} );

	glfwMakeContextCurrent(windowHandle);
	glewExperimental = true;

	if( glewInit() != GLEW_OK ) {
		logger::fatal( "Failed to initialize GLEW!" );
		return false;
	}

	auto& renderer = RenderSystem::instance();

	// clear invalid error generated by buggy GLEW
	glGetError();

	// specify window size to OpenGL
	glViewport(0, 0, width, height);

	// Time to enter the third dimension!
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_CULL_FACE);

	// allow to override color if the depth is equal
	renderer.setDepthFunc(GL_LEQUAL);
	renderer.depthTest(true);

	// enable alpha blending
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	srand(time(0));

	// remove frame cap - for performance testing
	// it's not 100% relible on all systems/drivers
	glfwSwapInterval(0);

	// stb image config
	stbi_set_flip_vertically_on_load(true);  
	stbi_flip_vertically_on_write(true);

	// initialize OpenCL
	return CLHelper::init();

}

void GLHelper::frame() {

	// Swap buffers
	glfwSwapBuffers(windowHandle);

	// poll for GLFW window events
	glfwPollEvents();

	// check for OpenGL error
	getError();
	
	// clear the screen and depth buffer
	glClear(GL_DEPTH_BUFFER_BIT);

}

byte* GLHelper::capture( int* width, int* height ) {

	// get window size
	int viewport[4];
	glGetIntegerv( GL_VIEWPORT, viewport );

	*width = viewport[2], *height = viewport[3];

	// create RGB image buffer
	byte* pixels = new byte[3 * *width * *height];

	// read from framebuffer
	glReadPixels(0, 0, *width, *height, GL_RGB, GL_UNSIGNED_BYTE, pixels);

	return pixels;
}

void GLHelper::screenshot( const std::string& path ) {
	
	int width, height;
	byte* pixels = GLHelper::capture( &width, &height );

	// write buffer to file
	if( stbi_write_png( path.c_str(), width, height, 3 /*RGB*/, pixels, 0 ) == 0 ) {
		logger::error("Failed to write screenshot to: '" + std::string(path) + "'!");
	}else{
		logger::info("Written screenshot to: '" + std::string(path) + "'");
	}

	// free buffer
	delete[] pixels;

}

cl_context_properties GLHelper::getContext() {
	#ifdef __linux__
		return (cl_context_properties) glXGetCurrentContext();
	#endif

	#ifdef _WIN32
		return (cl_context_properties) wglGetCurrentContext();
	#endif

	logger::fatal("Unable to get OpenGL context on unsupported system!");
	throw std::runtime_error("Unsupported OS!");
}

cl_context_properties GLHelper::getDisplay() {
	#ifdef __linux__
		return (cl_context_properties) glXGetCurrentDisplay();
	#endif

	#ifdef _WIN32
		return (cl_context_properties) wglGetCurrentDC();
	#endif

	logger::fatal("Unable to get display context on unsupported system!");
	throw std::runtime_error("Unsupported OS!");
}

void GLHelper::getError( const char* origin ) {
	GLenum err = glGetError();

	std::string name;

	switch( err ) {
		case GL_NO_ERROR: name = "GL_NO_ERROR"; break;
		case GL_INVALID_ENUM: name = "GL_INVALID_ENUM"; break;
		case GL_INVALID_VALUE: name = "GL_INVALID_VALUE"; break;
		case GL_INVALID_OPERATION: name = "GL_INVALID_OPERATION"; break;
		case GL_INVALID_FRAMEBUFFER_OPERATION: name = "GL_INVALID_FRAMEBUFFER_OPERATION"; break;
		case GL_OUT_OF_MEMORY: name = "GL_OUT_OF_MEMORY"; break;
		case GL_STACK_UNDERFLOW: name = "GL_STACK_UNDERFLOW"; break;
		case GL_STACK_OVERFLOW: name = "GL_STACK_OVERFLOW"; break;
		default: name = "UNKNOWN";
	}

	std::string location = origin == nullptr ? "" : std::string(", at: '") + origin + std::string("'"); 

	if( err != GL_NO_ERROR ) {
		logger::warn( "OpenGL Error: " + std::to_string(err) + ", " + name + location + "!" );
	}

	std::cout << std::flush;
}

int GLHelper::getSizeOf( GLenum thing ) {
	switch( thing ) {
		case GL_TRIANGLES: return 3;
		case GL_LINES: return 2;
		case GL_FLOAT: return sizeof(float);
		// TODO add more

		default: throw std::runtime_error("Unsupported OpenGL enum! id: " + std::to_string(thing));
	}
}

void GLHelper::vertexAttribute( GLint index, GLint length, GLenum type, GLsizei stride, GLsizei offset, GLsizei size, GLboolean normalize ) {
	glVertexAttribPointer(index, length, type, normalize, stride * size, (GLvoid*) (long) (offset * size));
	glEnableVertexAttribArray(index);
}

ShaderProgram* GLHelper::loadShaderProgram( std::string name ) {
	ShaderProgramBuilder builder;
	bool vertex = builder.compileFile( "assets/" + name + "/vertex.glsl", GL_VERTEX_SHADER );
	bool fragment = builder.compileFile( "assets/" + name + "/fragment.glsl", GL_FRAGMENT_SHADER );

	if( vertex && fragment ) {
		
		if( builder.link() ) {
			logger::info( "Loaded OpenGL shader program: '" + name + "'" );
			return builder.build();
		}

	}

	throw std::runtime_error("OpenGL shader program failed to load!");
}

